package com.kisman.cc.module.exploit;

import com.kisman.cc.Kisman;
import com.kisman.cc.event.events.DamageBlockEvent;
import com.kisman.cc.event.events.PlayerMoveEvent;
import com.kisman.cc.module.Category;
import com.kisman.cc.module.Module;
import com.kisman.cc.setting.Setting;
import com.kisman.cc.util.BlockUtil;
import com.kisman.cc.util.InventoryUtil;
import com.kisman.cc.util.MathUtil;
import com.kisman.cc.util.RenderUtil;
import i.gishreloaded.gishcode.utils.TimerUtils;
import me.zero.alpine.listener.EventHandler;
import me.zero.alpine.listener.Listener;
import net.minecraft.block.Block;
import net.minecraft.block.BlockLiquid;
import net.minecraft.init.Blocks;
import net.minecraft.item.ItemStack;
import net.minecraft.network.play.client.CPacketAnimation;
import net.minecraft.network.play.client.CPacketPlayerDigging;
import net.minecraft.util.EnumFacing;
import net.minecraft.util.EnumHand;
import net.minecraft.util.math.AxisAlignedBB;
import net.minecraft.util.math.BlockPos;
import net.minecraftforge.client.event.RenderWorldLastEvent;
import net.minecraftforge.fml.common.eventhandler.SubscribeEvent;

import java.awt.*;

public class PacketMine extends Module {
    private final Setting speed = new Setting("Speed", this, 0.8f, 0.1f, 1, false);
    public final Setting instant = new Setting("Instant", this, true);
    private final Setting silent = new Setting("Silent", this, true);
    private final Setting strict = new Setting("Strict", this, false);
    private final Setting autoSwitch = new Setting("Auto Switch", this, true);
    private final Setting render = new Setting("Render", this, true);
    private final Setting renderMode = new Setting("Render Mode", this, RenderMode.FADE);
    private final Setting instantAttempts = new Setting("Instant Attempts", this, 8, 0, 20, true);
    private final Setting range = new Setting("Range", this, 16, 4, 30, true);
    private final Setting packetSpam = new Setting("Packet Spam", this, 1, 1, 10, true);

    public static PacketMine instance;

    private BlockPos currentPos;
    private final TimerUtils timer = new TimerUtils();
    private long start;
    private int oldSlot, delay, rebreakCount;
    private boolean swap = false, checked, strictCheck;

    public PacketMine() {
        super("PacketMine", "PacketMine", Category.EXPLOIT);

        instance = this;

        register(speed);
        register(instant);
        register(silent);
        register(strict);
        register(autoSwitch);
        register(render);
        register(renderMode);
        register(instantAttempts);
        register(packetSpam);
    }

    public void onEnable() {
        Kisman.EVENT_BUS.subscribe(listener);
        Kisman.EVENT_BUS.subscribe(dmg);
        rebreakCount = 0;
        oldSlot = -1;
        currentPos = null;
        delay = 0;
    }

    public void onDisable() {
        Kisman.EVENT_BUS.unsubscribe(listener);
        Kisman.EVENT_BUS.unsubscribe(dmg);
    }

    public void update() {
        if(mc.player == null || mc.world == null) return;

        if (swap) {
            mc.player.connection.sendPacket(new CPacketPlayerDigging(CPacketPlayerDigging.Action.STOP_DESTROY_BLOCK, currentPos, EnumFacing.DOWN));
            if (delay >= 2) {
                InventoryUtil.switchToSlot(oldSlot, false);
                swap = false;
                if (!instant.getValBoolean() && currentPos != null) currentPos = null;
                delay = 0;
            }
            delay++;
        }
    }

    @EventHandler
    private final Listener<DamageBlockEvent> dmg = new Listener<>(event -> {
        if (swap) {
            event.cancel();
            return;
        }

        if (!BlockUtil.canBlockBeBroken(event.getBlockPos())) return;
        if (currentPos != null) {
            if (event.getBlockPos().toLong() == currentPos.toLong()) {
                if (!swap && getBlockProgress(currentPos, mc.player.inventory.getStackInSlot(InventoryUtil.findBestToolSlot(currentPos)), start) <= 1 - speed.getValDouble() && mc.world.getBlockState(currentPos).getBlock() != Blocks.AIR) {
                    if (silent.getValBoolean()) swapTo();
                    mc.player.connection.sendPacket(new CPacketPlayerDigging(CPacketPlayerDigging.Action.START_DESTROY_BLOCK, currentPos, EnumFacing.DOWN));
                    event.cancel();
                }
                return;
            }

            if (event.getBlockPos().toLong() != currentPos.toLong()) {
                mc.player.connection.sendPacket(new CPacketPlayerDigging(CPacketPlayerDigging.Action.ABORT_DESTROY_BLOCK, currentPos, event.getFaceDirection()));
                mc.playerController.isHittingBlock = false;
            }
        }

        mc.player.connection.sendPacket(new CPacketAnimation(EnumHand.MAIN_HAND));
        for (int j = 0; j < packetSpam.getValInt(); j++) mc.player.connection.sendPacket(new CPacketPlayerDigging(CPacketPlayerDigging.Action.START_DESTROY_BLOCK, event.getBlockPos(), event.getFaceDirection()));
        mc.player.connection.sendPacket(new CPacketPlayerDigging(CPacketPlayerDigging.Action.STOP_DESTROY_BLOCK, event.getBlockPos(), EnumFacing.DOWN));
        currentPos = event.getBlockPos();
        start = System.currentTimeMillis();
        strictCheck = true;
        timer.reset();
        event.cancel();
    });

    @EventHandler
    private final Listener<PlayerMoveEvent> listener = new Listener<>(event -> {
        if (currentPos != null) {
            if (instant.getValBoolean()) {
                if (mc.world.getBlockState(currentPos).getBlock() == Blocks.AIR) {
                    if (!checked) {
                        rebreakCount = 0;
                        checked = true;
                        start = System.currentTimeMillis();
                        timer.reset();
                        strictCheck = false;
                    }
                } else {
                    if (strict.getValBoolean() && !strictCheck) {
                        Block block = mc.world.getBlockState(currentPos).getBlock();
                        if (!(block.equals(Blocks.ENDER_CHEST) || block.equals(Blocks.ANVIL) || block.equals(Blocks.AIR))) {
                            rebreakCount = 0;
                            currentPos = null;
                            timer.reset();
                            strictCheck = true;
                            return;
                        }
                    }
                    checked = false;
                }
            }

            if (getBlockProgress(currentPos, mc.player.inventory.getStackInSlot(InventoryUtil.findBestToolSlot(currentPos)), start) <= 1 - speed.getValDouble() && mc.world.getBlockState(currentPos).getBlock() != Blocks.AIR) if (autoSwitch.getValBoolean()) if(!swapTo()) return;
            if (!swap) oldSlot = mc.player.inventory.currentItem;
            if (currentPos != null && mc.player.getDistanceSq(currentPos) >= MathUtil.square(range.getValInt())) currentPos = null;
        }
        try {mc.playerController.blockHitDelay = 0;} catch (Exception ignored) {}
    });

    private float getBlockProgress(BlockPos blockPos, ItemStack stack, long start) {
        return (float) MathUtil.clamp(1 - ((System.currentTimeMillis() - start) / (double) InventoryUtil.time(blockPos, stack)), 0, 1);
    }

    private boolean swapTo() {
        if (rebreakCount > instantAttempts.getValInt() - 1 && instantAttempts.getValInt() != 0) {
            currentPos = null;
            rebreakCount = 0;
            return false;
        }
        InventoryUtil.switchToSlot(InventoryUtil.findBestToolSlot(currentPos), false);
        if (silent.getValBoolean()) {
            mc.player.connection.sendPacket(new CPacketPlayerDigging(CPacketPlayerDigging.Action.STOP_DESTROY_BLOCK, currentPos, EnumFacing.DOWN));
            rebreakCount++;
            if (!instant.getValBoolean()) currentPos = null;
            InventoryUtil.switchToSlot(oldSlot, false);
        } else swap = true;
        return true;
    }

    @SubscribeEvent
    public void onRenderWorld(RenderWorldLastEvent event) {
        if (currentPos == null || !render.getValBoolean() || mc.world.getBlockState(currentPos).getBlock() == Blocks.AIR || mc.world.getBlockState(currentPos).getBlock() instanceof BlockLiquid) return;
        AxisAlignedBB bb = mc.world.getBlockState(currentPos).getSelectedBoundingBox(mc.world, currentPos);
        float progress = getBlockProgress(currentPos, mc.player.inventory.getStackInSlot(InventoryUtil.findBestToolSlot(currentPos)), start);
        if (progress <= 1 - speed.getValDouble()) RenderUtil.drawBoxESP(bb, Color.GREEN, Color.GREEN, 1f, true, true, Color.GREEN.getAlpha(), 255);
        else {
            if (renderMode.getValString().equalsIgnoreCase(RenderMode.FADE.name())) RenderUtil.drawBoxESP(bb, Color.RED, Color.RED, 1f, true, true, Color.RED.getAlpha(), 255);
            else RenderUtil.drawProgressBox(bb, progress, Color.RED);
        }
    }

    public enum RenderMode {FADE, EXPAND}
}
